#!/usr/bin/ansible-playbook
# Ansible Playbook v1.9 (fixed) - Multiple Instances Support
# Fixed: loop_control error with block (compatible with Ansible 2.8.1+)
# Last updated: 2025-10-23

- name: Normalize server name
  hosts: localhost
  gather_facts: no
  tasks:
    - name: Extract short hostname from FQDN
      set_fact:
        target_host: "{{ server.split('.')[0] if (server is defined and '.' in server) else (server | default('localhost')) }}"
      run_once: true
      
    - name: Add target host dynamically
      add_host:
        name: "{{ target_host }}"
        groups: dynamic_targets
      changed_when: false

- name: Update application on target server
  hosts: dynamic_targets
  gather_facts: no
  
  vars:
    app_base_dir: "/site/app"
    htdoc_base_dir: "/site/share/htdoc/"
    htdoc_data_dir: "/site/share/htdoc/htdoc.data"
    tmp_dir: "/site/ansible/tmp/ansible-deploy"
    remote_tmp_dir: "/tmp/ansible"
    
    app_instances_raw: "{{ app }}"
    app_instances: "{{ app_instances_raw.split(',') | map('trim') | list }}"
    base_app_name: "{{ app_instances[0].split('_')[0] }}"
    distrib_url: "{{ distr_url }}"
    unpack_archive: "{{ unpack | default(true) | bool }}"
    validate_webapp: "{{ validate_web_inf | default(true) | bool }}"
    deploy_mode: "{{ mode | default('deliver') }}"
#    restart_mode_param: "{{ restart_mode | default('now') }}"
    
# ================
# Validate parameters
# ================     
    
  tasks:
    - name: Validate input parameters
      tags: [always, validate]
      fail:
        msg: "Parameter '{{ item.name }}' is required. Please provide it with -e '{{ item.name }}=value'"
      when: item.value == ''
      loop:
        - { name: 'server', value: "{{ server | default('') }}" }
        - { name: 'app', value: "{{ app_instances_raw }}" }
        - { name: 'distr_url', value: "{{ distrib_url }}" }
      loop_control:
        label: "{{ item.name }}"
          
    - name: Display parsed instances
      set_fact:
        instances_count: "{{ app_instances | length }}"

    - name: Validate deploy mode
      fail:
        msg: "Invalid mode '{{ deploy_mode }}'. Allowed values: 'deliver' or 'update'"
      when: deploy_mode not in ['deliver', 'update']
        
    - name: Display validated input parameters
      debug:
        msg:
          - "Target server: {{ inventory_hostname }}"
          - "Application instances ({{ instances_count }}): {{ app_instances | join(', ') }}"
          - "Base application name: {{ base_app_name }}"
          - "Distr URL: {{ distrib_url }}"
          - "Deploy mode: {{ deploy_mode }}"
          - "Unpack archive: {{ unpack_archive }}"
          - "Validate webapp structure: {{ validate_webapp }}"
#          - "Restart mode: {{ restart_mode_param }}"

# ================
# Prepare app distr on Ansible server
# ================
    - name: Prepare distribution on Ansible control node
      tags: [always, prepare]
      delegate_to: localhost
      run_once: true
      block:
        - name: Create temp directory on Ansible control node
          file:
            path: "{{ tmp_dir }}"
            state: directory
            mode: '0755'
      
        - name: Check distribution URL availability
          uri:
            url: "{{ distrib_url }}"
            method: HEAD
            return_content: no
            status_code: 200
            timeout: 10
          register: url_check
          ignore_errors: yes
          check_mode: no

        - name: Fail if URL is not accessible
          fail:
            msg: "Distribution URL is not accessible: {{ distrib_url }}"
          when: url_check is failed

        - name: Download distrib to Ansible server
          get_url:
            url: "{{ distrib_url }}"
            dest: "{{ tmp_dir }}/{{ distrib_url | basename }}"
            mode: '0644'
            timeout: 300
            force: yes
          register: download_result

        - name: Extract distribution filename
          set_fact:
            distr_filename: "{{ distrib_url | basename }}"

        - name: Extract archive name without extension
          set_fact:
            archive_name_without_ext: "{{ distr_filename | regex_replace('\\.(war|jar|zip)$', '') }}"

        - name: Detect archive type
          set_fact:
            archive_type: "{{ distr_filename | regex_replace('^.*\\.(war|jar|zip)$', '\\1') }}"

        - name: Validate archive type
          fail:
            msg: "Unsupported archive type. Only .war, .jar, and .zip files are supported. Got: {{ distr_filename }}"
          when: archive_type not in ['war', 'jar', 'zip']

        - name: Generate current timestamp
          set_fact:
            current_datetime: "{{ lookup('pipe', 'TZ=Asia/Novosibirsk date +%Y%m%d_%H%M%S') }}"
            current_date: "{{ lookup('pipe', 'TZ=Asia/Novosibirsk date +%Y%m%d') }}"
            current_time: "{{ lookup('pipe', 'TZ=Asia/Novosibirsk date +%H%M%S') }}"

        - name: Extract version from filename
          set_fact:
            app_version: "{{ distr_filename | regex_replace('^.*-([0-9]+\\.[0-9]+[^.]*?)\\.(war|jar|zip)$', '\\1') }}"

        - name: Display extracted information
          debug:
            msg:
              - "Distribution file: {{ distr_filename }}"
              - "Archive name without extension: {{ archive_name_without_ext }}"
              - "Archive type: {{ archive_type }}"
              - "Version: {{ app_version }}"
              - "Timestamp: {{ current_date }} {{ current_time }}"
              - "Download size: {{ download_result.size | default('unknown') }} bytes"
              - "Will unpack: {{ unpack_archive }}"
          
# ================
# Copy distr to target server
# ================

    - name: Transfer distribution to target server
      tags: [always, transfer]
      block:
        - name: Create temp dir on target server
          file:
            path: "{{ remote_tmp_dir }}"
            state: directory
            mode: '0755'
        
        - name: Copy distribution from Ansible server to target server
          copy:
            src: "{{ tmp_dir }}/{{ distr_filename }}"
            dest: "{{ remote_tmp_dir }}/{{ distr_filename }}"
            mode: '0644'
          register: copy_result

        - name: Verify file was copied
          stat:
            path: "{{ remote_tmp_dir }}/{{ distr_filename }}"
          register: copied_file

        - name: Display copy result
          debug:
            msg: "File copied successfully: {{ copied_file.stat.size }} bytes"
          when: copied_file.stat.exists

# ================
# Update app instance
# ================

    - name: Update application instance
      tags: [always, update]
      block:
        - name: Set deployment variables
          set_fact:
            deploy_dir_name: "{{ current_date }}_{{ current_time }}_{{ archive_name_without_ext }}"
            deploy_path: "{{ htdoc_data_dir }}/{{ base_app_name }}/{{ current_date }}_{{ current_time }}_{{ archive_name_without_ext }}"

        - name: Create deployment directory
          file:
            path: "{{ deploy_path }}"
            state: directory
            mode: '0755'
          when: unpack_archive

# ================
# Unpack archive
# ================
        
        - name: Unarchive to deployment directory
          unarchive:
            src: "{{ remote_tmp_dir }}/{{ distr_filename }}"
            dest: "{{ deploy_path }}"
            remote_src: yes
            list_files: no
          register: unarchive_result
          when: unpack_archive

        - name: Verify WAR/ZIP structure (WEB-INF check)
          stat:
            path: "{{ deploy_path }}/WEB-INF"
          register: webapp_check
          when: 
            - unpack_archive
            - validate_webapp
            - archive_type in ['war', 'zip']

        - name: Check for nested WAR files if no WEB-INF found
          find:
            paths: "{{ deploy_path }}"
            patterns: "*.war"
            recurse: yes
            file_type: file
          register: nested_war_search
          when:
            - unpack_archive
            - archive_type == 'zip'
            - webapp_check is defined
            - not webapp_check.stat.exists

        - name: Display found nested WAR files
          debug:
            msg: "Found nested WAR files: {{ nested_war_search.files | map(attribute='path') | list }}"
          when:
            - unpack_archive
            - archive_type == 'zip'
            - nested_war_search is defined
            - nested_war_search.matched > 0

# ================
# Handle nested WAR files in ZIP
# ================

        - name: Extract nested WAR file
          block:
            - name: Set nested WAR path
              set_fact:
                nested_war_path: "{{ nested_war_search.files[0].path }}"
                temp_extract_dir: "{{ deploy_path }}_temp_war_extract"

            - name: Create temporary extraction directory
              file:
                path: "{{ temp_extract_dir }}"
                state: directory
                mode: '0755'

            - name: Unarchive nested WAR file
              unarchive:
                src: "{{ nested_war_path }}"
                dest: "{{ temp_extract_dir }}"
                remote_src: yes

            - name: Verify nested WAR structure
              stat:
                path: "{{ temp_extract_dir }}/WEB-INF"
              register: nested_webapp_check
              when: validate_webapp

            - name: Fail if nested WAR structure is invalid
              fail:
                msg: "Invalid nested WAR structure: WEB-INF directory not found in {{ nested_war_path }}"
              when: 
                - validate_webapp
                - not nested_webapp_check.stat.exists

            - name: Clear original deploy path
              file:
                path: "{{ deploy_path }}"
                state: absent

            - name: Recreate deploy path
              file:
                path: "{{ deploy_path }}"
                state: directory
                mode: '0755'

            - name: Move extracted WAR contents to deploy path
              shell: "mv {{ temp_extract_dir }}/* {{ deploy_path }}/"
              args:
                warn: false

            - name: Remove temporary extraction directory
              file:
                path: "{{ temp_extract_dir }}"
                state: absent

            - name: Display nested WAR extraction result
              debug:
                msg: 
                  - "Nested WAR extracted successfully"
                  - "Source WAR: {{ nested_war_path }}"
                  - "Deploy path: {{ deploy_path }}"
                  - "Validation: {{ 'enabled' if validate_webapp else 'disabled' }}"

          when:
            - unpack_archive
            - archive_type == 'zip'
            - nested_war_search is defined
            - nested_war_search.matched > 0
          
        - name: Fail if ZIP has no valid structure
          fail:
            msg: "Invalid ZIP structure: neither WEB-INF directory, nested WAR files, nor nested JAR files found in {{ deploy_path }}"
          when: 
            - unpack_archive
            - validate_webapp
            - archive_type == 'zip'
            - webapp_check is defined
            - not webapp_check.stat.exists
            - nested_war_search is defined
            - nested_war_search.matched == 0
            - nested_jar_search is defined
            - nested_jar_search.matched is defined
            - nested_jar_search.matched == 0

# ================
# Handle nested JAR files in ZIP
# ================

        - name: Check for nested JAR files if no WAR found
          find:
            paths: "{{ deploy_path }}"
            patterns: "*.jar"
            recurse: yes
            file_type: file
          register: nested_jar_search
          when:
            - unpack_archive
            - archive_type == 'zip'
            - webapp_check is defined
            - not webapp_check.stat.exists
            - nested_war_search is defined
            - nested_war_search.matched == 0

        - name: Display found nested JAR files
          debug:
            msg: "Found nested JAR files: {{ nested_jar_search.files | map(attribute='path') | list }}"
          when:
            - unpack_archive
            - archive_type == 'zip'
            - nested_jar_search is defined
            - nested_jar_search.matched is defined
            - nested_jar_search.matched > 0

        - name: Copy nested JAR file to deployment directory
          block:
            - name: Set nested JAR path and filename
              set_fact:
                nested_jar_path: "{{ nested_jar_search.files[0].path }}"
                nested_jar_filename: "{{ nested_jar_search.files[0].path | basename }}"
                final_jar_path: "{{ deploy_path }}/{{ nested_jar_search.files[0].path | basename }}"

            - name: Copy JAR to deploy path
              copy:
                src: "{{ nested_jar_path }}"
                dest: "{{ final_jar_path }}"
                remote_src: yes
                mode: '0644'
              register: jar_copy_result

            - name: Find all files and directories except the JAR
              find:
                paths: "{{ deploy_path }}"
                file_type: any
                recurse: yes
                excludes: "{{ nested_jar_filename }}"
              register: files_to_remove

            - name: Remove extracted ZIP contents (keep only JAR)
              file:
                path: "{{ item.path }}"
                state: absent
              loop: "{{ files_to_remove.files }}"
              when: item.path != final_jar_path

            - name: Verify JAR was copied
              stat:
                path: "{{ final_jar_path }}"
              register: copied_jar_check

            - name: Display nested JAR copy result
              debug:
                msg: 
                  - "Nested JAR copied successfully"
                  - "Source JAR: {{ nested_jar_path }}"
                  - "Destination: {{ final_jar_path }}"
                  - "Size: {{ copied_jar_check.stat.size }} bytes"
                  - "Removed {{ files_to_remove.matched }} items"

          when:
            - unpack_archive
            - archive_type == 'zip'
            - nested_jar_search is defined
            - nested_jar_search.matched is defined
            - nested_jar_search.matched > 0

        - name: Fail if WAR structure is invalid
          fail:
            msg: "Invalid WAR structure: WEB-INF directory not found in {{ deploy_path }}"
          when: 
            - unpack_archive
            - validate_webapp
            - archive_type == 'war'
            - webapp_check is defined
            - not webapp_check.stat.exists

        - name: Display unpack result
          debug:
            msg: "Archive unpacked successfully to {{ deploy_path }}"
          when: unpack_archive

        - name: Display validation skip notice
          debug:
            msg: 
              - "WARNING: Webapp structure validation is disabled"
              - "Archive unpacked without WEB-INF verification"
              - "Deploy path: {{ deploy_path }}"
          when:
            - unpack_archive
            - not validate_webapp

# ================
# Copy archive without unpacking (JAR/executable)
# ================

        - name: Copy archive without unpacking
          copy:
            src: "{{ remote_tmp_dir }}/{{ distr_filename }}"
            dest: "{{ deploy_path }}/{{ distr_filename }}"
            remote_src: yes
            mode: '0644'
          register: direct_copy_result
          when: not unpack_archive

        - name: Verify direct copy
          stat:
            path: "{{ deploy_path }}/{{ distr_filename }}"
          register: direct_copy_check
          when: not unpack_archive
          
        - name: Display direct copy result
          debug:
            msg: 
              - "Archive copied without unpacking"
              - "Location: {{ deploy_path }}/{{ distr_filename }}"
              - "Size: {{ direct_copy_check.stat.size }} bytes"
          when: 
            - not unpack_archive
            - direct_copy_check.stat.exists

# ================
# Update symbolic link (only in 'update' mode)
# ================
# Update symbolic links for multiple instances (only in 'update' mode)
# ================

        - name: Initialize instance tracking lists
          set_fact:
            updated_instances: []
            skipped_instances: []
            symlink_target: "{{ deploy_path if unpack_archive else deploy_path + '/' + distr_filename }}"
          when: deploy_mode == 'update'

        - name: Check if instance symlinks exist
          stat:
            path: "{{ htdoc_base_dir }}/{{ item }}"
          register: instance_symlink_checks
          loop: "{{ app_instances }}"
          when: deploy_mode == 'update'

        - name: Update symlinks for existing instances
          block:
            - name: Get current symlink information
              stat:
                path: "{{ htdoc_base_dir }}/{{ item.item }}"
              register: instance_symlink_info
              loop: "{{ instance_symlink_checks.results }}"
              when: 
                - item.stat is defined
                - item.stat.exists
              loop_control:
                label: "{{ item.item }}"

            - name: Remove old symlinks
              file:
                path: "{{ htdoc_base_dir }}/{{ item.item }}"
                state: absent
              loop: "{{ instance_symlink_checks.results }}"
              when:
                - item.stat is defined
                - item.stat.exists
              loop_control:
                label: "{{ item.item }}"

            - name: Create new symlinks
              file:
                src: "{{ symlink_target }}"
                dest: "{{ htdoc_base_dir }}/{{ item.item }}"
                state: link
                force: yes
              loop: "{{ instance_symlink_checks.results }}"
              when:
                - item.stat is defined
                - item.stat.exists
              register: create_symlinks_result
              loop_control:
                label: "{{ item.item }}"

            - name: Build updated instances list
              set_fact:
                updated_instances: "{{ updated_instances + [item.item] }}"
              loop: "{{ instance_symlink_checks.results }}"
              when:
                - item.stat is defined
                - item.stat.exists
              loop_control:
                label: "{{ item.item }}"

            - name: Build skipped instances list
              set_fact:
                skipped_instances: "{{ skipped_instances + [item.item] }}"
              loop: "{{ instance_symlink_checks.results }}"
              when:
                - item.stat is defined
                - not item.stat.exists
              loop_control:
                label: "{{ item.item }}"

          when: 
            - deploy_mode == 'update'
            - instance_symlink_checks.results is defined

        - name: Display symlink update summary
          debug:
            msg:
              - "=== Symlink Update Summary ==="
              - "Total instances: {{ app_instances | length }}"
              - "Successfully updated ({{ updated_instances | length }}): {{ updated_instances | join(', ') if updated_instances | length > 0 else 'none' }}"
              - "Skipped - symlink not found ({{ skipped_instances | length }}): {{ skipped_instances | join(', ') if skipped_instances | length > 0 else 'none' }}"
              - "New symlink target: {{ symlink_target }}"
          when: deploy_mode == 'update'

# ================
# Cleanup
# ================

    - name: Cleanup temporary files
      tags: [always, cleanup]
      block:
        - name: Remove distribution from remote temp
          file:
            path: "{{ remote_tmp_dir }}/{{ distr_filename }}"
            state: absent
          
        - name: Display deployment summary
          debug:
            msg:
              - "=== Deployment Summary ==="
              - "Base application: {{ base_app_name }}"
              - "Instances ({{ instances_count }}): {{ app_instances | join(', ') }}"
              - "Deploy mode: {{ deploy_mode | upper }}"
              - "Archive type: {{ archive_type | upper }}"
              - "Archive name (without ext): {{ archive_name_without_ext }}"
              - "Version: {{ app_version }}"
              - "Unpacked: {{ unpack_archive }}"
              - "Deploy path: {{ deploy_path }}"
              - "Symlinks updated: {{ updated_instances | length if deploy_mode == 'update' else 0 }}"
              - "Symlinks skipped: {{ skipped_instances | length if deploy_mode == 'update' else 0 }}"
              - "Deployment completed successfully"
