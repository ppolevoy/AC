#!/usr/bin/ansible-playbook
# Ansible Playbook v1.0 - Docker Compose Image Version Update
# Purpose: Update image version in docker-compose.yml files
# Last updated: 2025-11-18

- name: Normalize server name
  hosts: localhost
  gather_facts: no
  tasks:
    - name: Extract short hostname from FQDN
      set_fact:
        target_host: "{{ server.split('.')[0] if (server is defined and '.' in server) else (server | default('localhost')) }}"
      run_once: true
      
    - name: Add target host dynamically
      add_host:
        name: "{{ target_host }}"
        groups: dynamic_targets
      changed_when: false

- name: Update Docker Compose image version
  hosts: dynamic_targets
  gather_facts: no
 
  vars:
    compose_filename: "docker-compose.yml"
    dry_run_mode: "{{ dry_run | default(false) | bool }}"
    service_name_param: "{{ service_name | default('') }}"
    
# ================
# Validate parameters
# ================
    
  tasks:
    - name: Validate input parameters
      tags: [always, validate]
      fail:
        msg: "Parameter '{{ item.name }}' is required. Please provide it with -e '{{ item.name }}=value'"
      when: item.value | length == 0
      loop:
        - { name: 'app_dir', value: "{{ app_dir | default('') }}" }
        - { name: 'img_url', value: "{{ img_url | default('') }}" }
      loop_control:
        label: "{{ item.name }}"
        
    - name: Extract image name and tag from img_url
      tags: [always, validate]
      set_fact:
        # Извлекаем последнюю часть после последнего /
        new_image_suffix: "{{ img_url.split('/')[-1] }}"
        # Извлекаем имя сервиса (до двоеточия)
        extracted_service_name: "{{ img_url.split('/')[-1].split(':')[0] }}"
        # Извлекаем тег версии (после двоеточия)
        new_version: "{{ img_url.split(':')[-1] }}"
        
    - name: Validate extracted values
      tags: [always, validate]
      fail:
        msg: "Could not extract image name and version from img_url: {{ img_url }}. Expected format: registry.example.com/project/service-name:version"
      when: new_image_suffix == img_url or new_version == img_url or ':' not in new_image_suffix
    
    - name: Set compose file path
      tags: [always, validate]
      set_fact:
        compose_file_path: "{{ app_dir }}/{{ compose_filename }}"
        # Используем service_name если указан, иначе извлеченное имя
        target_service_name: "{{ service_name_param if service_name_param | length > 0 else extracted_service_name }}"
      
    - name: Display validated input parameters
      tags: [always, validate]
      debug:
        msg:
          - "Target server: {{ inventory_hostname }}"
          - "Application directory: {{ app_dir }}"
          - "Compose file: {{ compose_file_path }}"
          - "Image URL: {{ img_url }}"
          - "New image suffix: {{ new_image_suffix }}"
          - "Target service name: {{ target_service_name }}"
          - "New version: {{ new_version }}"
          - "Dry-run mode: {{ dry_run_mode }}"

# ================
# Check environment
# ================

    - name: Check environment prerequisites
      tags: [always, check]
      block:
        - name: Check if docker-compose file exists
          stat:
            path: "{{ compose_file_path }}"
          register: compose_file_stat
          
        - name: Fail if docker-compose file doesn't exist
          fail:
            msg: "Docker Compose file {{ compose_file_path }} does not exist"
          when: not compose_file_stat.stat.exists
        
        - name: Read docker-compose file content
          slurp:
            path: "{{ compose_file_path }}"
          register: compose_content_base64
          
        - name: Decode docker-compose content
          set_fact:
            compose_content: "{{ compose_content_base64.content | b64decode }}"
        
        - name: Check if service exists in docker-compose
          shell: "grep -E '^\\s*{{ target_service_name }}:' {{ compose_file_path }}"
          register: service_check
          failed_when: false
          changed_when: false
          
        - name: Fail if service not found
          fail:
            msg: "Service '{{ target_service_name }}' not found in {{ compose_file_path }}"
          when: service_check.rc != 0
          
        - name: Extract current image line for the service
          shell: |
            awk '/^[[:space:]]*{{ target_service_name }}:/ {found=1} found && /^[[:space:]]*image:/ {print; exit}' {{ compose_file_path }}
          register: current_image_line
          changed_when: false
          
        - name: Fail if image parameter not found for service
          fail:
            msg: "Image parameter not found for service '{{ target_service_name }}' in {{ compose_file_path }}"
          when: current_image_line.stdout | length == 0
          
        - name: Extract current image value
          set_fact:
            current_image_full: "{{ current_image_line.stdout | regex_replace('^\\s*image:\\s*', '') | trim }}"
            
        - name: Extract current image suffix (after last /)
          set_fact:
            current_image_suffix: "{{ current_image_full.split('/')[-1] }}"
            current_version: "{{ current_image_full.split(':')[-1] }}"
          
        - name: Display current image information
          debug:
            msg:
              - "Service: {{ target_service_name }}"
              - "Current full image: {{ current_image_full }}"
              - "Current image suffix: {{ current_image_suffix }}"
              - "Current version: {{ current_version }}"

# ================
# Backup docker-compose file
# ================

    - name: Create backup of docker-compose file
      tags: [always, backup]
      block:
        - name: Generate backup timestamp
          set_fact:
            backup_timestamp: "{{ lookup('pipe', 'date +%Y%m%d%H%M%S') }}"
    
        - name: Backup docker-compose file
          copy:
            src: "{{ compose_file_path }}"
            dest: "{{ compose_file_path }}.backup.{{ backup_timestamp }}"
            remote_src: yes
          when: not dry_run_mode
          register: backup_result
          
        - name: Display backup information
          debug:
            msg: 
              - "Backup created: {{ compose_file_path }}.backup.{{ backup_timestamp }}"
              - "Backup timestamp: {{ backup_timestamp }}"
          when: not dry_run_mode
          
        - name: Display dry-run backup notice
          debug:
            msg: "DRY-RUN: Would create backup at {{ compose_file_path }}.backup.{{ backup_timestamp }}"
          when: dry_run_mode

# ================
# Update image in docker-compose
# ================
    
    - name: Update image version in docker-compose file
      tags: [always, update]
      block:
        - name: Build regex pattern for replacement
          set_fact:
            # Паттерн ищет строку image для конкретного сервиса и захватывает все до последнего /
            replace_pattern: "(^\\s*image:\\s+.*/)({{ current_image_suffix | regex_escape }})"
            replace_replacement: "\\1{{ new_image_suffix }}"
        
        - name: Update image version in docker-compose.yml
          replace:
            path: "{{ compose_file_path }}"
            regexp: "{{ replace_pattern }}"
            replace: "{{ replace_replacement }}"
            backup: no
          when: not dry_run_mode
          register: update_result

        - name: Display dry-run update notice
          debug:
            msg: 
              - "DRY-RUN: Would update image in {{ compose_file_path }}"
              - "DRY-RUN: Service: {{ target_service_name }}"
              - "DRY-RUN: Current: {{ current_image_full }}"
              - "DRY-RUN: New: {{ current_image_full.split('/')[:-1] | join('/') }}/{{ new_image_suffix }}"
          when: dry_run_mode

        - name: Read updated docker-compose file
          slurp:
            path: "{{ compose_file_path }}"
          register: updated_compose_base64
          when: not dry_run_mode
          
        - name: Extract updated image line
          shell: |
            awk '/^[[:space:]]*{{ target_service_name }}:/ {found=1} found && /^[[:space:]]*image:/ {print; exit}' {{ compose_file_path }}
          register: updated_image_line
          changed_when: false
          when: not dry_run_mode
          
        - name: Extract updated image value
          set_fact:
            updated_image_full: "{{ updated_image_line.stdout | regex_replace('^\\s*image:\\s*', '') | trim }}"
          when: 
            - not dry_run_mode
            - updated_image_line is defined
            
        - name: Verify update was successful
          fail:
            msg: "Image update verification failed. Image was not updated correctly."
          when:
            - not dry_run_mode
            - updated_image_full is defined
            - new_image_suffix not in updated_image_full

        - name: Display updated image
          debug:
            msg: "Updated image: {{ updated_image_full }}"
          when: 
            - not dry_run_mode
            - updated_image_full is defined

# ================
# Summary
# ================

    - name: Display deployment summary
      tags: [always]
      debug:
        msg:
          - "=== Update Summary ==="
          - "Target server: {{ inventory_hostname }}"
          - "Application directory: {{ app_dir }}"
          - "Docker Compose file: {{ compose_file_path }}"
          - "Service name: {{ target_service_name }}"
          - "Image change: {{ current_image_full }} → {{ current_image_full.split('/')[:-1] | join('/') }}/{{ new_image_suffix }}"
          - "Version change: {{ current_version }} → {{ new_version }}"
          - "Backup file: {{ compose_file_path }}.backup.{{ backup_timestamp }}"
          - "Image URL: {{ img_url }}"
          - "Dry-run mode: {{ dry_run_mode }}"
          - "Status: {{ 'DRY-RUN COMPLETED (no changes made)' if dry_run_mode else 'UPDATE COMPLETED SUCCESSFULLY' }}"
