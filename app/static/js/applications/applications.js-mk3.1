/**
 * Faktura Apps - Управление приложениями
 * Оптимизированная версия с полным сохранением функционала
 */

(function() {
    'use strict';

    // ========================================
    // КОНСТАНТЫ И КОНФИГУРАЦИЯ
    // ========================================
    const CONFIG = {
        PROGRESS: {
            START: 10,
            FETCH_COMPLETE: 70,
            PARSE_COMPLETE: 100
        },
        CACHE_LIFETIME: 5 * 60 * 1000, // 5 минут
        ANIMATION_DELAYS: {
            FADE_IN: 100,
            FIELD_STAGGER: 100,
            MIN_LOADER_TIME: 600
        },
        MAX_ARTIFACTS_DISPLAY: 20,
        PAGE_SIZE: 10
    };

    // ========================================
    // МОДУЛЬ УПРАВЛЕНИЯ СОСТОЯНИЕМ
    // ========================================
    const StateManager = {
        // Основное состояние приложения
        state: {
            allApplications: [],
            selectedItems: {
                applications: new Set(),
                groups: new Set()
            },
            expandedGroups: [],
            selectedServerId: 'all',
            currentPage: 1,
            pageSize: CONFIG.PAGE_SIZE,
            sortColumn: 'name',
            sortDirection: 'asc',
            searchQuery: '',
            groupingEnabled: false
        },

        // Кэш артефактов
        artifactsCache: {},

        // Активное выпадающее меню
        activeDropdown: null,

        // Методы работы с состоянием
        clearSelection() {
            this.state.selectedItems.applications.clear();
            this.state.selectedItems.groups.clear();
        },

        addSelectedApp(appId) {
            this.state.selectedItems.applications.add(appId);
        },

        removeSelectedApp(appId) {
            this.state.selectedItems.applications.delete(appId);
        },

        isAppSelected(appId) {
            return this.state.selectedItems.applications.has(appId);
        },

        getSelectedAppIds() {
            return Array.from(this.state.selectedItems.applications);
        },

        getAppById(appId) {
            return this.state.allApplications.find(app => app.id == appId);
        },

        clearArtifactsCache(appId = null) {
            if (appId) {
                delete this.artifactsCache[`app_${appId}`];
                console.log(`Кэш артефактов очищен для приложения ${appId}`);
            } else {
                this.artifactsCache = {};
                console.log('Весь кэш артефактов очищен');
            }
        },

        getArtifactsCacheAge(appId) {
            const cacheKey = `app_${appId}`;
            if (this.artifactsCache[cacheKey]) {
                return (Date.now() - this.artifactsCache[cacheKey].timestamp) / 1000;
            }
            return Infinity;
        },

        saveTableState() {
            this.state.expandedGroups = [];
            document.querySelectorAll('.group-row.expanded').forEach(row => {
                const groupName = row.getAttribute('data-group');
                if (groupName) {
                    this.state.expandedGroups.push(groupName);
                }
            });
            console.log('Сохранено состояние групп:', this.state.expandedGroups);
        }
    };

    // ========================================
    // МОДУЛЬ РАБОТЫ С API
    // ========================================
    const ApiService = {
        async loadServers() {
            try {
                const response = await fetch('/api/servers');
                const data = await response.json();
                return data.success ? data.servers : [];
            } catch (error) {
                console.error('Ошибка загрузки серверов:', error);
                showError('Не удалось загрузить список серверов');
                return [];
            }
        },

        async loadApplications(serverId = null) {
            try {
                let url = '/api/applications';
                if (serverId && serverId !== 'all') {
                    url += `?server_id=${serverId}`;
                }
                const response = await fetch(url);
                const data = await response.json();
                return data.success ? data.applications : [];
            } catch (error) {
                console.error('Ошибка загрузки приложений:', error);
                showError('Не удалось загрузить список приложений');
                return [];
            }
        },

        async loadArtifacts(appId, limit = CONFIG.MAX_ARTIFACTS_DISPLAY, showProgress = false) {
            try {
                if (showProgress) {
                    const progressBar = document.querySelector('.progress-bar');
                    if (progressBar) {
                        progressBar.style.width = '30%';
                    }
                }

                const response = await fetch(`/api/applications/${appId}/artifacts?limit=${limit}`);
                
                if (showProgress) {
                    const progressBar = document.querySelector('.progress-bar');
                    if (progressBar) {
                        progressBar.style.width = '70%';
                    }
                }

                const data = await response.json();
                
                if (showProgress) {
                    const progressBar = document.querySelector('.progress-bar');
                    if (progressBar) {
                        progressBar.style.width = '100%';
                    }
                }

                if (data.success && data.versions && data.versions.length > 0) {
                    // Сортируем версии: сначала релизные, потом dev, потом snapshot
                    const sortedVersions = data.versions.sort((a, b) => {
                        const aLower = a.version.toLowerCase();
                        const bLower = b.version.toLowerCase();
                        
                        // Приоритеты: release = 3, обычные = 2, dev = 1, snapshot = 0
                        const getPriority = (version) => {
                            const vLower = version.version.toLowerCase();
                            if (version.is_release) return 3;
                            if (vLower.includes('snapshot')) return 0;
                            if (vLower.includes('dev')) return 1;
                            return 2;
                        };
                        
                        const aPriority = getPriority(a);
                        const bPriority = getPriority(b);
                        
                        if (aPriority !== bPriority) {
                            return bPriority - aPriority; // Больший приоритет первым
                        }
                        
                        // Если приоритеты одинаковые, сортируем по версии в обратном порядке
                        return bLower.localeCompare(aLower);
                    });
                    
                    console.log(`Загружено ${sortedVersions.length} версий для приложения ${appId}`);
                    return sortedVersions.slice(0, limit); // Применяем лимит
                }
                
                return null;
            } catch (error) {
                console.error('Ошибка загрузки артефактов:', error);
                // Не показываем глобальную ошибку, только локальную в форме
                return null;
            }
        },

        async executeAction(appIds, action) {
            try {
                const response = await fetch('/api/applications/batch_action', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ app_ids: appIds, action })
                });
                return await response.json();
            } catch (error) {
                console.error('Ошибка выполнения действия:', error);
                showError(`Не удалось выполнить действие "${action}"`);
                return { success: false, error: error.message };
            }
        },

        async updateApplication(appId, updateParams) {
            try {
                const response = await fetch(`/api/applications/${appId}/update`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(updateParams)
                });
                return await response.json();
            } catch (error) {
                console.error('Ошибка обновления приложения:', error);
                return { success: false, error: error.message };
            }
        },

        async getApplicationInfo(appId) {
            try {
                const response = await fetch(`/api/applications/${appId}`);
                const data = await response.json();
                return data.success ? data.application : null;
            } catch (error) {
                console.error('Ошибка получения информации:', error);
                showError('Не удалось получить информацию о приложении');
                return null;
            }
        }
    };

    // ========================================
    // МОДУЛЬ РАБОТЫ С АРТЕФАКТАМИ
    // ========================================
    const ArtifactsManager = {
        async loadWithCache(appId, showProgress = false) {
            const now = Date.now();
            const cacheKey = `app_${appId}`;
            const cache = StateManager.artifactsCache[cacheKey];

            // Проверяем кэш
            if (cache && (now - cache.timestamp) < CONFIG.CACHE_LIFETIME) {
                console.log(`Используем кэш артефактов для приложения ${appId} (возраст: ${Math.round((now - cache.timestamp)/1000)}с)`);
                return cache.data;
            }

            // Загружаем свежие данные
            const artifacts = await ApiService.loadArtifacts(appId, CONFIG.MAX_ARTIFACTS_DISPLAY, showProgress);
            if (artifacts && artifacts.length > 0) {
                StateManager.artifactsCache[cacheKey] = {
                    timestamp: now,
                    data: artifacts
                };
                return artifacts;
            }

            return null;
        },

        createVersionSelect(artifacts, currentValue) {
            if (!artifacts || artifacts.length === 0) {
                return '<option value="">Нет доступных версий</option>';
            }

            const options = artifacts.map(version => {
                let label = version.version;
                let className = '';
                const versionLower = version.version.toLowerCase();

                if (versionLower.includes('snapshot')) {
                    label += ' 🔸';
                    className = 'version-snapshot';
                } else if (versionLower.includes('dev')) {
                    label += ' 🔹';
                    className = 'version-dev';
                } else if (version.is_release) {
                    label += ' ✅';
                    className = 'version-release';
                }

                const selected = version.url === currentValue ? 'selected' : '';
                return `<option value="${version.url}" class="${className}" ${selected}>${label}</option>`;
            }).join('');

            return options + '<option value="custom" class="custom-option">➕ Указать вручную...</option>';
        }
    };

    // ========================================
    // МОДУЛЬ РАБОТЫ С UI
    // ========================================
    const UIRenderer = {
        elements: {
            applicationsTableBody: null,
            selectAllCheckbox: null,
            serverDropdown: null,
            searchInput: null,
            sortSelects: null,
            groupToggleBtn: null,
            actionButtons: {}
        },

        init() {
            this.elements.applicationsTableBody = document.getElementById('applications-table-body');
            this.elements.selectAllCheckbox = document.getElementById('select-all-checkbox');
            this.elements.serverDropdown = document.getElementById('server-dropdown');
            this.elements.searchInput = document.getElementById('search-input');
            this.elements.groupToggleBtn = document.getElementById('group-toggle-btn');
            
            // Кнопки действий
            this.elements.actionButtons = {
                start: document.getElementById('start-btn'),
                restart: document.getElementById('restart-btn'),
                stop: document.getElementById('stop-btn'),
                update: document.getElementById('update-btn'),
                unload: document.getElementById('unload-btn')
            };
        },

        renderServers(servers) {
            const serverList = document.getElementById('server-list');
            if (!serverList) return;

            serverList.innerHTML = '<li data-server-id="all">Все серверы</li>';
            servers.forEach(server => {
                const li = document.createElement('li');
                li.setAttribute('data-server-id', server.id);
                li.textContent = server.name;
                serverList.appendChild(li);
            });
        },

        renderApplications(applications) {
            const tbody = this.elements.applicationsTableBody;
            if (!tbody) return;

            // Сохраняем состояние перед обновлением
            StateManager.saveTableState();

            tbody.innerHTML = '';
            
            if (applications.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" class="table-loading">Нет приложений</td></tr>';
                this.updatePagination(0);
                return;
            }

            if (StateManager.state.groupingEnabled) {
                this.renderGroupedApplications(applications);
            } else {
                this.renderFlatApplications(applications);
            }

            // Восстанавливаем состояние после рендеринга
            this.restoreTableState();
            this.setupTableEventHandlers();
            this.restoreCheckboxState();
            
            // Обновляем состояние "выбрать все" после рендеринга
            this.updateSelectAllState();
        },

        renderFlatApplications(applications) {
            const totalPages = Math.ceil(applications.length / StateManager.state.pageSize);
            
            // Корректируем текущую страницу если она выходит за пределы
            if (StateManager.state.currentPage > totalPages && totalPages > 0) {
                StateManager.state.currentPage = totalPages;
            }
            
            const paginatedApps = this.paginateData(applications);
            paginatedApps.forEach(app => {
                const row = this.createApplicationRow(app, false);
                if (row && this.elements.applicationsTableBody) {
                    this.elements.applicationsTableBody.appendChild(row);
                }
            });
            this.updatePagination(applications.length);
        },

        renderGroupedApplications(applications) {
            const groups = this.groupApplications(applications);
            const totalPages = Math.ceil(groups.length / StateManager.state.pageSize);
            
            // Корректируем текущую страницу если она выходит за пределы
            if (StateManager.state.currentPage > totalPages && totalPages > 0) {
                StateManager.state.currentPage = totalPages;
            }
            
            const paginatedGroups = this.paginateData(groups);

            paginatedGroups.forEach(group => {
                if (group.apps.length === 1) {
                    const row = this.createApplicationRow(group.apps[0], false);
                    if (row && this.elements.applicationsTableBody) {
                        this.elements.applicationsTableBody.appendChild(row);
                    }
                } else {
                    this.renderApplicationGroup(group);
                }
            });

            this.updatePagination(groups.length);
        },

        renderApplicationGroup(group) {
            const tbody = this.elements.applicationsTableBody;
            if (!tbody) return;
            
            // Создаем строку группы
            const groupRow = this.createGroupRow(group.name, group.apps);
            tbody.appendChild(groupRow);

            // Создаем контейнер для дочерних элементов
            const wrapperRow = document.createElement('tr');
            wrapperRow.className = 'child-wrapper';
            wrapperRow.setAttribute('data-group', group.name);
            
            // По умолчанию скрываем дочерние элементы
            wrapperRow.style.display = 'none';

            const wrapperCell = document.createElement('td');
            wrapperCell.setAttribute('colspan', '6');

            const childContainer = document.createElement('div');
            childContainer.className = 'child-container';

            const childTable = document.createElement('table');
            childTable.className = 'child-table';

            const childTableBody = document.createElement('tbody');
            
            // Добавляем приложения группы
            group.apps.forEach(app => {
                const childRow = this.createChildApplicationRow(app, group.name);
                childTableBody.appendChild(childRow);
            });

            childTable.appendChild(childTableBody);
            childContainer.appendChild(childTable);
            wrapperCell.appendChild(childContainer);
            wrapperRow.appendChild(wrapperCell);
            tbody.appendChild(wrapperRow);
        },

        createApplicationRow(app, isChild) {
            const row = document.createElement('tr');
            row.className = isChild ? 'app-row child-row' : 'app-row';
            row.setAttribute('data-app-id', app.id);
            row.setAttribute('data-app-name', app.name.toLowerCase());

            const statusDot = app.status === 'online' ? 
                '<span class="service-dot"></span>' : 
                '<span class="service-dot offline"></span>';

            row.innerHTML = `
                <td>
                    <div class="checkbox-container">
                        <label class="custom-checkbox">
                            <input type="checkbox" class="app-checkbox" data-app-id="${app.id}">
                            <span class="checkmark"></span>
                        </label>
                    </div>
                </td>
                <td class="service-name ${isChild ? 'child-indent' : ''}">
                    ${app.name}
                    <div class="dist-details">
                        <div>Время запуска: ${app.start_time ? new Date(app.start_time).toLocaleString() : 'Н/Д'}</div>
                        <div>Путь приложения: ${app.path || 'Н/Д'}</div>
                        <div>Путь к дистрибутиву: ${app.distr_path || 'Н/Д'}</div>
                    </div>
                </td>
                <td>${app.version || 'Н/Д'}</td>
                <td>${statusDot} ${app.status}</td>
                <td>${app.server_name || 'Н/Д'}</td>
                <td>${this.createActionsMenu(app)}</td>
            `;

            return row;
        },

        createGroupRow(groupName, apps) {
            const row = document.createElement('tr');
            row.className = 'group-row';
            row.setAttribute('data-group', groupName);

            const versions = new Set(apps.map(app => app.version || 'Н/Д'));
            const versionText = versions.size === 1 ? 
                (apps[0].version || 'Н/Д') : 
                '<span class="version-different">*</span>';

            const hasOffline = apps.some(app => app.status !== 'online');
            const statusDot = hasOffline ? 
                '<span class="service-dot offline"></span>' : 
                '<span class="service-dot"></span>';

            row.innerHTML = `
                <td>
                    <div class="checkbox-container">
                        <label class="custom-checkbox">
                            <input type="checkbox" class="group-checkbox" data-group="${groupName}">
                            <span class="checkmark"></span>
                        </label>
                    </div>
                </td>
                <td class="service-name">
                    <div class="group-name-container">
                        <span class="group-toggle">▶</span>
                        <span class="group-name">${groupName} (${apps.length})</span>
                    </div>
                </td>
                <td>${versionText}</td>
                <td>${statusDot}</td>
                <td>${apps[0].server_name || 'Н/Д'}</td>
                <td>${this.createGroupActionsMenu(groupName, apps)}</td>
            `;

            return row;
        },

        createChildApplicationRow(app, groupName) {
            const row = document.createElement('tr');
            row.className = 'app-child-row';
            row.setAttribute('data-app-id', app.id);
            row.setAttribute('data-parent', groupName);

            const statusDot = app.status === 'online' ? 
                '<span class="service-dot"></span>' : 
                '<span class="service-dot offline"></span>';

            row.innerHTML = `
                <td>
                    <div class="checkbox-container">
                        <label class="custom-checkbox">
                            <input type="checkbox" class="app-checkbox" data-app-id="${app.id}">
                            <span class="checkmark"></span>
                        </label>
                    </div>
                </td>
                <td class="service-name">
                    ${app.name}
                    <div class="dist-details">
                        <div>Время запуска: ${app.start_time ? new Date(app.start_time).toLocaleString() : 'Н/Д'}</div>
                        <div>Путь приложения: ${app.path || 'Н/Д'}</div>
                        <div>Путь к дистрибутиву: ${app.distr_path || 'Н/Д'}</div>
                    </div>
                </td>
                <td>${app.version || 'Н/Д'}</td>
                <td>${statusDot} ${app.status}</td>
                <td>${app.server_name || 'Н/Д'}</td>
                <td>${this.createActionsMenu(app)}</td>
            `;

            return row;
        },

        createActionsMenu(app) {
            const isOnline = app.status === 'online';
            return `
                <div class="actions-menu">
                    <button class="actions-button">...</button>
                    <div class="actions-dropdown">
                        <a href="#" class="app-info-btn" data-app-id="${app.id}">Информация</a>
                        <a href="#" class="app-start-btn ${isOnline ? 'disabled' : ''}" data-app-id="${app.id}">Запустить</a>
                        <a href="#" class="app-stop-btn ${!isOnline ? 'disabled' : ''}" data-app-id="${app.id}">Остановить</a>
                        <a href="#" class="app-restart-btn ${!isOnline ? 'disabled' : ''}" data-app-id="${app.id}">Перезапустить</a>
                        <a href="#" class="app-update-btn" data-app-id="${app.id}">Обновить</a>
                    </div>
                </div>
            `;
        },

        createGroupActionsMenu(groupName, apps) {
            const hasOnline = apps.some(app => app.status === 'online');
            const hasOffline = apps.some(app => app.status !== 'online');
            
            return `
                <div class="actions-menu">
                    <button class="actions-button">...</button>
                    <div class="actions-dropdown">
                        <a href="#" class="group-info-btn" data-group="${groupName}">Информация</a>
                        <a href="#" class="group-start-btn ${!hasOffline ? 'disabled' : ''}" data-group="${groupName}">Запустить все</a>
                        <a href="#" class="group-stop-btn ${!hasOnline ? 'disabled' : ''}" data-group="${groupName}">Остановить все</a>
                        <a href="#" class="group-restart-btn ${!hasOnline ? 'disabled' : ''}" data-group="${groupName}">Перезапустить все</a>
                        <a href="#" class="group-update-btn" data-group="${groupName}">Обновить все</a>
                    </div>
                </div>
            `;
        },

        groupApplications(applications) {
            const groups = {};
            applications.forEach(app => {
                const groupName = app.group_name || app.name;
                if (!groups[groupName]) {
                    groups[groupName] = { name: groupName, apps: [] };
                }
                groups[groupName].apps.push(app);
            });
            return Object.values(groups).sort((a, b) => a.name.localeCompare(b.name));
        },

        paginateData(data) {
            const { currentPage, pageSize } = StateManager.state;
            const startIndex = (currentPage - 1) * pageSize;
            const endIndex = startIndex + pageSize;
            return data.slice(startIndex, endIndex);
        },

        updatePagination(totalItems) {
            const totalPages = Math.ceil(totalItems / StateManager.state.pageSize);
            const paginationContainer = document.getElementById('pagination');
            if (!paginationContainer) return;

            let html = '';
            const { currentPage } = StateManager.state;

            // Кнопка "Предыдущая"
            if (currentPage > 1) {
                html += `<button class="page-btn" data-page="${currentPage - 1}">◀</button>`;
            }

            // Номера страниц
            for (let i = 1; i <= totalPages; i++) {
                if (i === 1 || i === totalPages || (i >= currentPage - 2 && i <= currentPage + 2)) {
                    html += `<button class="page-btn ${i === currentPage ? 'active' : ''}" data-page="${i}">${i}</button>`;
                } else if (i === currentPage - 3 || i === currentPage + 3) {
                    html += '<span>...</span>';
                }
            }

            // Кнопка "Следующая"
            if (currentPage < totalPages) {
                html += `<button class="page-btn" data-page="${currentPage + 1}">▶</button>`;
            }

            paginationContainer.innerHTML = html;
        },

        updateActionButtonsState(hasSelection) {
            const actionButtons = {
                start: document.getElementById('start-btn'),
                restart: document.getElementById('restart-btn'),
                stop: document.getElementById('stop-btn'),
                update: document.getElementById('update-btn'),
                unload: document.getElementById('unload-btn')
            };
            
            Object.values(actionButtons).forEach(btn => {
                if (!btn) return;
                btn.disabled = !hasSelection;
                btn.classList.toggle('disabled', !hasSelection);
            });
        },

        setupTableEventHandlers() {
            // Обработчики для строк приложений - раскрытие деталей
            document.querySelectorAll('.app-row').forEach(row => {
                row.addEventListener('click', function(e) {
                    if (e.target.closest('.checkbox-container') || e.target.closest('.actions-menu')) {
                        return;
                    }
                    this.classList.toggle('expanded');
                });
            });

            // Обработчики для дочерних строк приложений в группах
            document.querySelectorAll('.app-child-row').forEach(row => {
                row.addEventListener('click', function(e) {
                    if (e.target.closest('.checkbox-container') || e.target.closest('.actions-menu')) {
                        return;
                    }
                    this.classList.toggle('expanded');
                });
            });

            // Обработчики для строк групп - раскрытие/сворачивание
            document.querySelectorAll('.group-row').forEach(row => {
                row.addEventListener('click', function(e) {
                    if (e.target.closest('.checkbox-container') || e.target.closest('.actions-menu')) {
                        return;
                    }
                    
                    const groupName = this.getAttribute('data-group');
                    const toggle = this.querySelector('.group-toggle');
                    const wrapperRow = document.querySelector(`.child-wrapper[data-group="${groupName}"]`);
                    
                    if (this.classList.contains('expanded')) {
                        // Сворачиваем
                        this.classList.remove('expanded');
                        if (toggle) {
                            toggle.style.transform = 'rotate(0deg)';
                        }
                        if (wrapperRow) {
                            wrapperRow.style.display = 'none';
                        }
                    } else {
                        // Раскрываем
                        this.classList.add('expanded');
                        if (toggle) {
                            toggle.style.transform = 'rotate(90deg)';
                        }
                        if (wrapperRow) {
                            wrapperRow.style.display = 'table-row';
                        }
                    }
                });
            });
        },

        restoreTableState() {
            // Восстанавливаем развернутые группы
            StateManager.state.expandedGroups.forEach(groupName => {
                const groupRow = document.querySelector(`.group-row[data-group="${groupName}"]`);
                const childWrapper = document.querySelector(`.child-wrapper[data-group="${groupName}"]`);
                const groupToggle = groupRow?.querySelector('.group-toggle');
                
                if (groupRow && childWrapper) {
                    groupRow.classList.add('expanded');
                    childWrapper.style.display = 'table-row';
                    if (groupToggle) {
                        groupToggle.style.transform = 'rotate(90deg)';
                    }
                }
            });
        },

        restoreCheckboxState() {
            StateManager.state.selectedItems.applications.forEach(appId => {
                const checkbox = document.querySelector(`.app-checkbox[data-app-id="${appId}"]`);
                if (checkbox) {
                    checkbox.checked = true;
                }
            });
            
            // Обновляем групповые чекбоксы
            document.querySelectorAll('.group-checkbox').forEach(groupCheckbox => {
                const groupName = groupCheckbox.dataset.group;
                this.updateGroupCheckbox(groupName);
            });
            
            // Обновляем состояние "выбрать все"
            this.updateSelectAllState();
            
            const hasSelection = StateManager.state.selectedItems.applications.size > 0;
            this.updateActionButtonsState(hasSelection);
        },

        updateGroupCheckbox(groupName) {
            const groupCheckbox = document.querySelector(`.group-checkbox[data-group="${groupName}"]`);
            if (!groupCheckbox) return;
            
            const childCheckboxes = document.querySelectorAll(`.child-wrapper[data-group="${groupName}"] .app-checkbox`);
            const checkedCount = Array.from(childCheckboxes).filter(cb => cb.checked).length;
            
            if (checkedCount === 0) {
                groupCheckbox.checked = false;
                groupCheckbox.indeterminate = false;
            } else if (checkedCount === childCheckboxes.length) {
                groupCheckbox.checked = true;
                groupCheckbox.indeterminate = false;
            } else {
                groupCheckbox.checked = false;
                groupCheckbox.indeterminate = true;
            }
        },

        updateSelectAllState() {
            const selectAllCheckbox = document.getElementById('select-all-checkbox');
            if (!selectAllCheckbox) return;
            
            const allCheckboxes = document.querySelectorAll('.app-checkbox');
            const checkedCheckboxes = document.querySelectorAll('.app-checkbox:checked');
            
            if (checkedCheckboxes.length === 0) {
                selectAllCheckbox.checked = false;
                selectAllCheckbox.indeterminate = false;
            } else if (checkedCheckboxes.length === allCheckboxes.length) {
                selectAllCheckbox.checked = true;
                selectAllCheckbox.indeterminate = false;
            } else {
                selectAllCheckbox.checked = false;
                selectAllCheckbox.indeterminate = true;
            }
        }
    };

    // ========================================
    // МОДУЛЬ МОДАЛЬНЫХ ОКОН
    // ========================================
    const ModalManager = {
        // Кэш содержимого групп
        groupContentCache: {},
        groupContentLoaded: {},

        showUpdateModal(appIds) {
            if (!appIds || appIds.length === 0) {
                showError('Не выбрано ни одного приложения');
                return;
            }

            // Группируем приложения
            const appGroups = {};
            appIds.forEach(appId => {
                const app = StateManager.getAppById(appId);
                if (app) {
                    const groupName = app.group_name || app.name;
                    if (!appGroups[groupName]) {
                        appGroups[groupName] = [];
                    }
                    appGroups[groupName].push(app);
                }
            });

            // Определяем тип модального окна
            if (Object.keys(appGroups).length === 1) {
                const groupName = Object.keys(appGroups)[0];
                const apps = appGroups[groupName];
                this.showSimpleUpdateModal(apps, apps.length === 1 ? 
                    `Обновление приложения: ${apps[0].name}` : 
                    `Обновление группы: ${groupName}`);
            } else {
                this.showTabsUpdateModal(appGroups, `Обновление ${appIds.length} приложений`);
            }
        },

        async showSimpleUpdateModal(apps, title) {
            const appIds = apps.map(app => app.id);
            const firstApp = apps[0];
            
            // Создаем содержимое модального окна с анимированным загрузчиком
            const modalContent = document.createElement('div');
            modalContent.className = 'update-modal-content';

            modalContent.innerHTML = `
                <form id="update-form" class="modal-form">
                    <input type="hidden" name="app_ids" value="${appIds.join(',')}">
                    <input type="hidden" id="current-app-id" value="${firstApp.id}">
                    
                    <div class="artifact-loading-container">
                        <label>Версия дистрибутива:</label>
                        <div class="artifact-loader">
                            <div class="skeleton-select">
                                <div class="skeleton-text">Загрузка списка версий...</div>
                                <div class="skeleton-arrow">▼</div>
                            </div>
                            <div class="loading-spinner">
                                <div class="spinner-ring"></div>
                            </div>
                            <div class="loading-progress">
                                <div class="progress-bar"></div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="form-group" id="custom-url-group" style="display: none;">
                        <label for="custom-distr-url">URL дистрибутива:</label>
                        <input type="text" id="custom-distr-url" name="custom_distr_url" class="form-control">
                    </div>
                    
                    <div class="form-group">
                        <label>Режим обновления:</label>
                        <div class="radio-group">
                            <label class="radio-label">
                                <input type="radio" name="restart_mode" value="restart" checked> В рестарт
                            </label>
                            <label class="radio-label">
                                <input type="radio" name="restart_mode" value="immediate"> Сейчас
                            </label>
                        </div>
                    </div>
                    
                    <div class="form-actions">
                        <button type="button" class="cancel-btn" onclick="closeModal()">Отмена</button>
                        <button type="submit" class="submit-btn">Обновить</button>
                    </div>
                </form>
            `;

            // Показываем модальное окно
            window.showModal(title, modalContent);

            // Загружаем артефакты с анимацией
            setTimeout(async () => {
                const startTime = Date.now();
                const artifacts = await ArtifactsManager.loadWithCache(firstApp.id, true);
                
                // Минимальное время показа загрузчика
                const elapsedTime = Date.now() - startTime;
                if (elapsedTime < 800) {
                    await new Promise(resolve => setTimeout(resolve, 800 - elapsedTime));
                }
                
                this.updateVersionSelector(artifacts, firstApp.distr_path, firstApp.id);
                
                if (!artifacts) {
                    // Показываем только локальное сообщение об ошибке
                    const container = document.querySelector('.artifact-loading-container');
                    if (container) {
                        container.innerHTML = `
                            <label for="distr-url">URL дистрибутива:</label>
                            <input type="text" id="distr-url" name="distr_url" class="form-control" value="${firstApp.distr_path || ''}" required>
                            <div class="error-message">Не удалось загрузить список версий</div>
                        `;
                    }
                }
            }, 100);

            // Обработчик отправки формы
            document.getElementById('update-form').addEventListener('submit', async (e) => {
                e.preventDefault();
                const formData = new FormData(e.target);
                await this.processUpdateForm(formData);
            });
        },

        async showTabsUpdateModal(appGroups, title) {
            const modalContent = document.createElement('div');
            
            // Создаем вкладки
            const tabsContainer = document.createElement('div');
            tabsContainer.className = 'modal-tabs';
            
            const form = document.createElement('form');
            form.id = 'update-form';
            form.className = 'modal-form';
            
            const dynamicContent = document.createElement('div');
            dynamicContent.id = 'dynamic-group-content';
            
            // Состояния групп
            const groupStates = {};
            const groupArtifacts = {};
            const excludedGroups = new Set(); // Исключенные группы
            
            // Очищаем кэши при открытии нового модального окна
            this.groupContentCache = {};
            this.groupContentLoaded = {};
            
            // Функция создания вкладки
            const createTab = (groupName, index, isActive) => {
                const tab = document.createElement('div');
                tab.className = `modal-tab ${isActive ? 'active' : ''}`;
                tab.setAttribute('data-group', groupName);
                
                const tabContent = document.createElement('span');
                tabContent.className = 'tab-content';
                tabContent.innerHTML = `${groupName} <span class="app-count">(${appGroups[groupName].length})</span>`;
                tab.appendChild(tabContent);
                
                // Кнопка удаления группы
                const removeBtn = document.createElement('button');
                removeBtn.className = 'tab-remove-btn';
                removeBtn.innerHTML = '×';
                removeBtn.title = 'Исключить группу из обновления';
                removeBtn.onclick = (e) => {
                    e.stopPropagation();
                    
                    // Добавляем в исключенные
                    excludedGroups.add(groupName);
                    
                    // Удаляем вкладку
                    tab.remove();
                    
                    // Если это была активная вкладка, переключаемся на другую
                    if (tab.classList.contains('active')) {
                        const remainingTabs = tabsContainer.querySelectorAll('.modal-tab');
                        if (remainingTabs.length > 0) {
                            remainingTabs[0].click();
                        } else {
                            dynamicContent.innerHTML = '<div class="no-groups-message">Все группы исключены из обновления</div>';
                        }
                    }
                    
                    // Удаляем из состояний
                    delete groupStates[groupName];
                    delete groupArtifacts[groupName];
                    delete this.groupContentCache[groupName];
                    delete this.groupContentLoaded[groupName];
                };
                tab.appendChild(removeBtn);
                
                return tab;
            };
            
            // Создаем вкладки для каждой группы
            Object.keys(appGroups).forEach((groupName, index) => {
                const tab = createTab(groupName, index, index === 0);
                tabsContainer.appendChild(tab);
                
                const apps = appGroups[groupName];
                const firstApp = apps[0];
                
                groupStates[groupName] = {
                    appIds: apps.map(app => app.id),
                    distrUrl: firstApp?.distr_path || '',
                    restartMode: 'restart',
                    artifactsLoaded: false
                };
                
                this.groupContentLoaded[groupName] = false;
            });
            
            modalContent.appendChild(tabsContainer);
            form.appendChild(dynamicContent);
            
            // Функция обновления содержимого вкладки
            const updateFormContent = async (groupName, force = false) => {
                const state = groupStates[groupName];
                const apps = appGroups[groupName];
                const firstApp = apps[0];
                
                // Проверяем кэш
                if (!force && this.groupContentLoaded[groupName] && this.groupContentCache[groupName]) {
                    console.log(`✨ Используем кэшированное содержимое для группы "${groupName}"`);
                    dynamicContent.innerHTML = this.groupContentCache[groupName];
                    
                    // Восстанавливаем обработчики
                    this.attachFormEventHandlers(groupName, groupStates, groupArtifacts, updateFormContent);
                    return;
                }
                
                // Показываем красивый загрузчик
                dynamicContent.innerHTML = `
                    <div class="loading-indicator">
                        <div class="spinner"></div>
                        <div>Загрузка данных группы ${groupName}...</div>
                    </div>
                `;
                
                const startTime = Date.now();
                
                // Загружаем артефакты если нужно
                let artifacts = groupArtifacts[groupName];
                let loadingError = false;
                
                if (!artifacts || force) {
                    artifacts = await ArtifactsManager.loadWithCache(firstApp.id, true);
                    if (artifacts) {
                        groupArtifacts[groupName] = artifacts;
                        state.artifactsLoaded = true;
                        console.log(`✅ Загружено ${artifacts.length} версий для группы "${groupName}"`);
                    } else {
                        loadingError = true;
                        console.error(`❌ Не удалось загрузить версии для группы "${groupName}"`);
                        // Не показываем глобальную ошибку, только локальную в форме
                    }
                }
                
                // Минимальное время показа загрузчика
                const elapsedTime = Date.now() - startTime;
                if (!this.groupContentLoaded[groupName] && elapsedTime < 600) {
                    await new Promise(resolve => setTimeout(resolve, 600 - elapsedTime));
                }
                
                // Создаем HTML содержимое
                let formHTML = `<div class="form-content-animated">`;
                formHTML += `<input type="hidden" id="app-ids" name="app_ids" value="${state.appIds.join(',')}">`;
                
                if (artifacts && artifacts.length > 0) {
                    formHTML += `
                        <div class="form-group animated-fade-in" style="animation-delay: 0.1s">
                            <div class="artifact-selector-wrapper">
                                <div class="artifact-selector-header">
                                    <label for="distr-url">
                                        Версия дистрибутива:
                                        <span class="version-count">(${artifacts.length} версий)</span>
                                    </label>
                                    <button type="button" class="refresh-artifacts-btn" data-group="${groupName}" title="Обновить список версий">
                                        <span class="refresh-icon">⟳</span>
                                    </button>
                                </div>
                                <select id="distr-url" name="distr_url" class="form-control artifact-select" required>
                                    ${ArtifactsManager.createVersionSelect(artifacts, state.distrUrl)}
                                </select>
                                ${StateManager.getArtifactsCacheAge(firstApp.id) < 60 ? 
                                    '<div class="cache-status"><span class="cache-fresh">✓ Данные актуальны</span></div>' : 
                                    '<div class="cache-status"><span class="cache-old">Обновлено ' + Math.round(StateManager.getArtifactsCacheAge(firstApp.id) / 60) + ' мин. назад</span></div>'
                                }
                            </div>
                        </div>
                        <div class="form-group animated-fade-in" id="custom-url-group" style="display: none; animation-delay: 0.2s">
                            <label for="custom-distr-url">URL дистрибутива:</label>
                            <input type="text" id="custom-distr-url" name="custom_distr_url" class="form-control">
                        </div>
                    `;
                } else {
                    const errorClass = loadingError ? 'field-with-error' : '';
                    formHTML += `
                        <div class="form-group animated-fade-in ${errorClass}" style="animation-delay: 0.1s">
                            <div class="distr-url-wrapper">
                                <label for="distr-url">URL дистрибутива:</label>
                                <input type="text" id="distr-url" name="distr_url" class="form-control" value="${state.distrUrl}" required>
                                ${loadingError ? `
                                    <div class="field-error-message">
                                        <span class="error-icon">⚠</span>
                                        Не удалось загрузить список версий. Введите URL вручную.
                                    </div>
                                ` : ''}
                            </div>
                        </div>
                    `;
                }
                
                formHTML += `
                    <div class="form-group animated-fade-in" style="animation-delay: 0.3s">
                        <label>Режим обновления:</label>
                        <div class="radio-group">
                            <label class="radio-label">
                                <input type="radio" name="restart_mode" value="restart" ${state.restartMode === 'restart' ? 'checked' : ''}> В рестарт
                            </label>
                            <label class="radio-label">
                                <input type="radio" name="restart_mode" value="immediate" ${state.restartMode === 'immediate' ? 'checked' : ''}> Сейчас
                            </label>
                        </div>
                    </div>
                    
                    <div class="group-apps-info animated-fade-in" style="animation-delay: 0.4s">
                        <label>Приложения в группе:</label>
                        <div class="apps-list">
                            ${apps.map(app => `<span class="app-badge">${app.name}</span>`).join('')}
                        </div>
                    </div>
                </div>`;
                
                // Сохраняем в кэш
                this.groupContentCache[groupName] = formHTML;
                this.groupContentLoaded[groupName] = true;
                
                // Обновляем содержимое с анимацией
                dynamicContent.style.opacity = '0';
                setTimeout(() => {
                    dynamicContent.innerHTML = formHTML;
                    dynamicContent.style.opacity = '1';
                    
                    // Обработчики событий
                    this.attachFormEventHandlers(groupName, groupStates, groupArtifacts, updateFormContent);
                }, 200);
            };
            
            // Обработчики вкладок
            tabsContainer.addEventListener('click', async (e) => {
                const tab = e.target.closest('.modal-tab');
                if (!tab || tab.classList.contains('active')) return;
                
                // Игнорируем клики по кнопке удаления
                if (e.target.classList.contains('tab-remove-btn')) return;
                
                // Сохраняем текущее состояние
                const activeTab = tabsContainer.querySelector('.modal-tab.active');
                if (activeTab) {
                    this.saveGroupState(activeTab.dataset.group, groupStates);
                }
                
                // Переключаем вкладку
                tabsContainer.querySelectorAll('.modal-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                
                // Загружаем содержимое (используем кэш если есть)
                await updateFormContent(tab.dataset.group);
            });
            
            // Кнопки действий формы
            const formActions = document.createElement('div');
            formActions.className = 'form-actions';
            formActions.innerHTML = `
                <button type="button" class="cancel-btn" onclick="closeModal()">Отмена</button>
                <button type="submit" class="submit-btn">Обновить</button>
            `;
            form.appendChild(formActions);
            
            modalContent.appendChild(form);
            
            // Обработчик отправки формы
            form.addEventListener('submit', async (e) => {
                e.preventDefault();
                
                // Сохраняем текущее состояние
                const activeTab = tabsContainer.querySelector('.modal-tab.active');
                if (activeTab) {
                    this.saveGroupState(activeTab.dataset.group, groupStates);
                }
                
                // Собираем все обновления (исключая удаленные группы)
                const updates = [];
                for (const groupName of Object.keys(groupStates)) {
                    if (excludedGroups.has(groupName)) continue; // Пропускаем исключенные группы
                    
                    const state = groupStates[groupName];
                    if (state.distrUrl && state.distrUrl.trim() && state.distrUrl !== 'custom') {
                        state.appIds.forEach(appId => {
                            const app = StateManager.getAppById(appId);
                            updates.push({
                                appId,
                                appName: app?.name,
                                groupName,
                                distr_url: state.distrUrl,
                                restart_mode: state.restartMode
                            });
                        });
                    }
                }
                
                if (updates.length > 0) {
                    await this.processMultipleUpdates(updates);
                } else {
                    showError('Укажите URL дистрибутива хотя бы для одной группы');
                }
            });
            
            // Показываем модальное окно
            window.showModal(title, modalContent);
            
            // Загружаем первую вкладку
            const firstGroup = Object.keys(appGroups)[0];
            await updateFormContent(firstGroup);
        },

        updateVersionSelector(artifacts, currentValue, appId = null) {
            const container = document.querySelector('.artifact-loading-container');
            if (!container) return;

            if (artifacts && artifacts.length > 0) {
                container.innerHTML = `
                    <div class="artifact-selector-wrapper">
                        <div class="artifact-selector-header">
                            <label for="distr-url">
                                Версия дистрибутива:
                                <span class="version-count">(${artifacts.length} версий)</span>
                            </label>
                            <button type="button" class="refresh-artifacts-btn" ${appId ? `data-app-id="${appId}"` : ''} title="Обновить список версий">
                                <span class="refresh-icon">⟳</span>
                            </button>
                        </div>
                        <select id="distr-url" name="distr_url" class="form-control artifact-select" required>
                            ${ArtifactsManager.createVersionSelect(artifacts, currentValue)}
                        </select>
                    </div>
                `;
            } else {
                container.innerHTML = `
                    <label for="distr-url">URL дистрибутива:</label>
                    <input type="text" id="distr-url" name="distr_url" class="form-control" value="${currentValue || ''}" required>
                    <div class="error-message">Не удалось загрузить список версий</div>
                `;
            }

            this.attachVersionSelectorHandlers(appId);
        },

        attachVersionSelectorHandlers(appId = null) {
            const select = document.getElementById('distr-url');
            const customGroup = document.getElementById('custom-url-group');
            
            if (select && select.tagName === 'SELECT' && customGroup) {
                select.addEventListener('change', function() {
                    if (this.value === 'custom') {
                        customGroup.style.display = 'block';
                        customGroup.classList.add('animated-slide-down');
                        document.getElementById('custom-distr-url').required = true;
                    } else {
                        customGroup.style.display = 'none';
                        document.getElementById('custom-distr-url').required = false;
                    }
                });
            }
            
            const refreshBtn = document.querySelector('.refresh-artifacts-btn');
            if (refreshBtn) {
                refreshBtn.addEventListener('click', async function() {
                    this.classList.add('rotating');
                    this.disabled = true;
                    
                    // Используем переданный appId или берем из скрытого поля
                    const targetAppId = this.dataset.appId || 
                                       document.getElementById('current-app-id')?.value || 
                                       StateManager.state.allApplications[0]?.id;
                    
                    if (targetAppId) {
                        StateManager.clearArtifactsCache(targetAppId);
                        const artifacts = await ArtifactsManager.loadWithCache(targetAppId, true);
                        ModalManager.updateVersionSelector(artifacts, '', targetAppId);
                        
                        if (artifacts) {
                            showNotification('Список версий обновлен');
                        }
                    }
                    
                    this.classList.remove('rotating');
                    this.disabled = false;
                });
            }
        },

        attachFormEventHandlers(groupName, groupStates, groupArtifacts, updateFormContent) {
            // Обработчик селектора версий
            const select = document.getElementById('distr-url');
            const customGroup = document.getElementById('custom-url-group');
            
            if (select && select.tagName === 'SELECT') {
                select.addEventListener('change', function() {
                    if (this.value === 'custom') {
                        customGroup.style.display = 'block';
                        customGroup.classList.add('animated-slide-down');
                        document.getElementById('custom-distr-url').required = true;
                    } else {
                        customGroup.style.display = 'none';
                        document.getElementById('custom-distr-url').required = false;
                    }
                });
            }
            
            // Обработчик кнопки обновления артефактов
            const refreshBtn = document.querySelector('.refresh-artifacts-btn');
            if (refreshBtn) {
                refreshBtn.addEventListener('click', async function() {
                    this.classList.add('rotating');
                    this.disabled = true;
                    
                    const group = this.dataset.group;
                    const apps = StateManager.state.allApplications.filter(app => 
                        (app.group_name || app.name) === group
                    );
                    
                    if (apps.length > 0) {
                        StateManager.clearArtifactsCache(apps[0].id);
                        delete groupArtifacts[group];
                        delete ModalManager.groupContentCache[group];
                        ModalManager.groupContentLoaded[group] = false;
                        
                        // Перезагружаем содержимое с force=true
                        await updateFormContent(group, true);
                    }
                    
                    this.classList.remove('rotating');
                    this.disabled = false;
                });
            }
        },

        saveGroupState(groupName, groupStates) {
            if (!groupStates[groupName]) return;
            
            const distrUrlElement = document.getElementById('distr-url');
            const customUrlElement = document.getElementById('custom-distr-url');
            const restartModeElement = document.querySelector('input[name="restart_mode"]:checked');
            
            let distrUrl = '';
            if (distrUrlElement) {
                if (distrUrlElement.tagName === 'SELECT') {
                    if (distrUrlElement.value === 'custom' && customUrlElement?.value) {
                        distrUrl = customUrlElement.value;
                    } else if (distrUrlElement.value !== 'custom') {
                        distrUrl = distrUrlElement.value;
                    }
                } else {
                    distrUrl = distrUrlElement.value;
                }
            }
            
            groupStates[groupName].distrUrl = distrUrl;
            groupStates[groupName].restartMode = restartModeElement?.value || 'restart';
        },

        async processUpdateForm(formData) {
            try {
                const appIds = formData.get('app_ids').split(',').filter(id => id);
                const distrUrl = formData.get('distr_url') === 'custom' ? 
                    formData.get('custom_distr_url') : formData.get('distr_url');
                const restartMode = formData.get('restart_mode');

                if (!distrUrl || distrUrl === 'custom') {
                    showError('Укажите URL дистрибутива');
                    return;
                }

                showNotification(`Запуск обновления для ${appIds.length} приложений...`);

                const results = [];
                for (const appId of appIds) {
                    const app = StateManager.getAppById(appId);
                    const updateParams = {
                        distr_url: distrUrl,
                        restart_mode: restartMode
                    };

                    if (app?.app_type === 'docker') {
                        updateParams.image_name = distrUrl;
                    }

                    const result = await ApiService.updateApplication(appId, updateParams);
                    results.push({ appId, success: result.success, error: result.error });
                }

                const successCount = results.filter(r => r.success).length;
                if (successCount === results.length) {
                    showNotification('Обновление успешно запущено');
                } else if (successCount > 0) {
                    showNotification(`Обновление запущено для ${successCount} из ${results.length} приложений`);
                } else {
                    showError('Не удалось запустить обновление');
                }

                await EventHandlers.loadApplications();
                closeModal();
            } catch (error) {
                console.error('Ошибка при обработке формы обновления:', error);
                showError('Произошла ошибка при обновлении');
            }
        },

        async processMultipleUpdates(updates) {
            try {
                showNotification(`Запуск обновления ${updates.length} приложений...`);
                
                const results = [];
                const errors = [];
                
                for (const update of updates) {
                    const app = StateManager.getAppById(update.appId);
                    const updateParams = {
                        distr_url: update.distr_url,
                        restart_mode: update.restart_mode
                    };
                    
                    if (app?.app_type === 'docker') {
                        updateParams.image_name = update.distr_url;
                    }
                    
                    const result = await ApiService.updateApplication(update.appId, updateParams);
                    
                    if (result.success) {
                        results.push(update);
                    } else {
                        errors.push({ ...update, error: result.error });
                    }
                }
                
                const successCount = results.length;
                const errorCount = errors.length;
                
                if (errorCount === 0) {
                    showNotification(`✅ Успешно запущено обновление для всех ${successCount} приложений`);
                } else if (successCount === 0) {
                    showError(`❌ Не удалось запустить обновление ни для одного приложения`);
                } else {
                    showNotification(`⚠️ Обновление запущено для ${successCount} из ${updates.length} приложений`);
                }
                
                if (errors.length > 0) {
                    console.error('Ошибки обновления:', errors);
                }
                
                await EventHandlers.loadApplications();
                closeModal();
            } catch (error) {
                console.error('Ошибка при массовом обновлении:', error);
                showError('Произошла ошибка при обновлении приложений');
            }
        }
    };

    // ========================================
    // МОДУЛЬ ОБРАБОТЧИКОВ СОБЫТИЙ
    // ========================================
    const EventHandlers = {
        init() {
            this.initDropdownHandlers();
            this.initServerSelection();
            this.initSearch();
            this.initSorting();
            this.initGrouping();
            this.initCheckboxHandlers();
            this.initActionButtons();
            this.initPagination();
            this.initTableActions();
            this.initRefreshButton();
        },

        initRefreshButton() {
            const refreshBtn = document.getElementById('refresh-btn');
            if (refreshBtn) {
                refreshBtn.addEventListener('click', function() {
                    this.classList.add('rotating');
                    EventHandlers.loadApplications().finally(() => {
                        this.classList.remove('rotating');
                    });
                });
            }
        },

        initDropdownHandlers() {
            // Создаем оверлей для выпадающих меню
            let dropdownOverlay = document.querySelector('.dropdown-overlay');
            if (!dropdownOverlay) {
                dropdownOverlay = document.createElement('div');
                dropdownOverlay.className = 'dropdown-overlay';
                document.body.appendChild(dropdownOverlay);
            }
            
            // Обработчик клика по кнопке меню
            document.body.addEventListener('click', (e) => {
                const actionButton = e.target.closest('.actions-button');
                if (actionButton) {
                    e.preventDefault();
                    e.stopPropagation();
                    this.toggleDropdown(actionButton);
                }
            });
            
            // Закрытие меню при клике на оверлей
            dropdownOverlay.addEventListener('click', () => {
                this.closeAllDropdowns();
            });
        },

        toggleDropdown(actionButton) {
            const dropdown = actionButton.nextElementSibling;
            const dropdownOverlay = document.querySelector('.dropdown-overlay');
            
            if (dropdown.classList.contains('show')) {
                this.closeAllDropdowns();
                return;
            }
            
            this.closeAllDropdowns();
            
            // Показываем оверлей и меню
            dropdownOverlay.style.display = 'block';
            this.positionDropdown(dropdown, actionButton);
            StateManager.activeDropdown = dropdown;
        },

        positionDropdown(dropdown, actionButton) {
            const buttonRect = actionButton.getBoundingClientRect();
            const spaceBelow = window.innerHeight - buttonRect.bottom;
            const showUpwards = spaceBelow < 200;
            
            dropdown.style.display = 'block';
            dropdown.style.opacity = '0';
            dropdown.classList.remove('dropdown-up');
            
            if (showUpwards) {
                dropdown.classList.add('dropdown-up');
                dropdown.style.bottom = (window.innerHeight - buttonRect.top) + 'px';
            } else {
                dropdown.style.top = buttonRect.bottom + 'px';
            }
            
            dropdown.style.right = (window.innerWidth - buttonRect.right) + 'px';
            dropdown.classList.add('show');
            dropdown.style.opacity = '1';
            actionButton.classList.add('active');
        },

        closeAllDropdowns() {
            const dropdownOverlay = document.querySelector('.dropdown-overlay');
            if (dropdownOverlay) {
                dropdownOverlay.style.display = 'none';
            }
            
            document.querySelectorAll('.actions-dropdown.show').forEach(dropdown => {
                dropdown.classList.remove('show');
                dropdown.style.display = '';
                
                const actionButton = dropdown.previousElementSibling;
                if (actionButton) {
                    actionButton.classList.remove('active');
                }
            });
            
            StateManager.activeDropdown = null;
        },

        async initServerSelection() {
            const servers = await ApiService.loadServers();
            UIRenderer.renderServers(servers);
            
            // Обработчик клика по dropdown серверов
            const serverDropdown = document.getElementById('server-dropdown');
            const serverList = document.getElementById('server-list');
            
            if (serverDropdown) {
                serverDropdown.addEventListener('click', (e) => {
                    e.stopPropagation();
                    serverDropdown.classList.toggle('open');
                });
            }
            
            // Обработчик выбора сервера
            if (serverList) {
                serverList.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const serverItem = e.target.closest('li');
                    if (serverItem) {
                        const serverId = serverItem.dataset.serverId;
                        const serverName = serverItem.textContent;
                        this.selectServer(serverId, serverName);
                        serverDropdown?.classList.remove('open');
                    }
                });
            }
            
            // Закрытие dropdown при клике вне его
            document.addEventListener('click', () => {
                serverDropdown?.classList.remove('open');
            });
        },

        selectServer(serverId, serverName) {
            StateManager.state.selectedServerId = serverId;
            const dropdown = document.getElementById('server-dropdown');
            if (dropdown) {
                dropdown.innerHTML = `${serverName} <span>▾</span>`;
            }
            StateManager.state.currentPage = 1;
            this.loadApplications();
        },

        initSearch() {
            const searchInput = document.getElementById('search-input');
            if (searchInput) {
                searchInput.addEventListener('input', (e) => {
                    StateManager.state.searchQuery = e.target.value.trim().toLowerCase();
                    StateManager.state.currentPage = 1;
                    this.filterAndDisplayApplications();
                });
            }
        },

        initSorting() {
            // Обработчики сортировки по клику на заголовки
            document.querySelectorAll('th.sortable').forEach(th => {
                th.addEventListener('click', function() {
                    const currentSortColumn = StateManager.state.sortColumn;
                    StateManager.state.sortColumn = this.getAttribute('data-sort');
                    
                    if (currentSortColumn === StateManager.state.sortColumn) {
                        StateManager.state.sortDirection = StateManager.state.sortDirection === 'asc' ? 'desc' : 'asc';
                    } else {
                        StateManager.state.sortDirection = 'asc';
                    }
                    
                    // Обновляем классы для отображения направления
                    document.querySelectorAll('th.sortable').forEach(header => {
                        header.classList.remove('sorted-asc', 'sorted-desc');
                    });
                    
                    this.classList.add(`sorted-${StateManager.state.sortDirection}`);
                    
                    EventHandlers.filterAndDisplayApplications();
                });
            });
        },

        initGrouping() {
            const groupToggleBtn = document.getElementById('group-toggle-btn');
            if (groupToggleBtn) {
                StateManager.state.groupingEnabled = groupToggleBtn.classList.contains('active');
                
                groupToggleBtn.addEventListener('click', () => {
                    groupToggleBtn.classList.toggle('active');
                    StateManager.state.groupingEnabled = groupToggleBtn.classList.contains('active');
                    StateManager.state.currentPage = 1;
                    this.filterAndDisplayApplications();
                });
            }
        },

        initCheckboxHandlers() {
            // Обработчик выбора всех
            const selectAllCheckbox = document.getElementById('select-all-checkbox');
            if (selectAllCheckbox) {
                selectAllCheckbox.addEventListener('change', (e) => {
                    const isChecked = e.target.checked;
                    
                    document.querySelectorAll('.app-checkbox').forEach(checkbox => {
                        checkbox.checked = isChecked;
                        const appId = checkbox.dataset.appId;
                        if (isChecked) {
                            StateManager.addSelectedApp(appId);
                        } else {
                            StateManager.removeSelectedApp(appId);
                        }
                    });
                    
                    // Обновляем групповые чекбоксы
                    document.querySelectorAll('.group-checkbox').forEach(checkbox => {
                        checkbox.checked = isChecked;
                    });
                    
                    UIRenderer.updateActionButtonsState(StateManager.state.selectedItems.applications.size > 0);
                });
            }
            
            // Делегирование событий для чекбоксов
            document.addEventListener('change', (e) => {
                if (e.target.classList.contains('app-checkbox')) {
                    const appId = e.target.dataset.appId;
                    if (e.target.checked) {
                        StateManager.addSelectedApp(appId);
                    } else {
                        StateManager.removeSelectedApp(appId);
                    }
                    
                    const hasSelection = StateManager.state.selectedItems.applications.size > 0;
                    UIRenderer.updateActionButtonsState(hasSelection);
                    
                    // Обновляем состояние "выбрать все"
                    UIRenderer.updateSelectAllState();
                    
                    // Обновляем состояние группового чекбокса
                    const parentGroup = e.target.closest('.child-wrapper')?.dataset.group;
                    if (parentGroup) {
                        UIRenderer.updateGroupCheckbox(parentGroup);
                    }
                }
                
                if (e.target.classList.contains('group-checkbox')) {
                    const groupName = e.target.dataset.group;
                    const isChecked = e.target.checked;
                    
                    // Выбираем/снимаем выбор со всех приложений группы
                    document.querySelectorAll(`.child-wrapper[data-group="${groupName}"] .app-checkbox`).forEach(checkbox => {
                        checkbox.checked = isChecked;
                        const appId = checkbox.dataset.appId;
                        if (isChecked) {
                            StateManager.addSelectedApp(appId);
                        } else {
                            StateManager.removeSelectedApp(appId);
                        }
                    });
                    
                    // Обновляем состояние "выбрать все"
                    UIRenderer.updateSelectAllState();
                    
                    const hasSelection = StateManager.state.selectedItems.applications.size > 0;
                    UIRenderer.updateActionButtonsState(hasSelection);
                }
            });
        },

        updateGroupCheckbox(groupName) {
            const groupCheckbox = document.querySelector(`.group-checkbox[data-group="${groupName}"]`);
            if (!groupCheckbox) return;
            
            const childCheckboxes = document.querySelectorAll(`.child-wrapper[data-group="${groupName}"] .app-checkbox`);
            const checkedCount = Array.from(childCheckboxes).filter(cb => cb.checked).length;
            
            if (checkedCount === 0) {
                groupCheckbox.checked = false;
                groupCheckbox.indeterminate = false;
            } else if (checkedCount === childCheckboxes.length) {
                groupCheckbox.checked = true;
                groupCheckbox.indeterminate = false;
            } else {
                groupCheckbox.checked = false;
                groupCheckbox.indeterminate = true;
            }
        },

        initActionButtons() {
            // Обработчики для кнопок действий
            const actionButtons = {
                start: document.getElementById('start-btn'),
                restart: document.getElementById('restart-btn'),
                stop: document.getElementById('stop-btn'),
                update: document.getElementById('update-btn'),
                unload: document.getElementById('unload-btn')
            };
            
            Object.entries(actionButtons).forEach(([action, button]) => {
                if (button) {
                    button.addEventListener('click', () => {
                        const selectedIds = StateManager.getSelectedAppIds();
                        if (selectedIds.length === 0) {
                            showError('Не выбрано ни одного приложения');
                            return;
                        }
                        
                        if (action === 'update') {
                            ModalManager.showUpdateModal(selectedIds);
                        } else {
                            this.handleBatchAction(selectedIds, action);
                        }
                    });
                }
            });
        },

        async handleBatchAction(appIds, action) {
            const apps = appIds.map(id => StateManager.getAppById(id)).filter(app => app);
            
            // Фильтруем приложения по доступности действия
            const availableApps = apps.filter(app => {
                if (action === 'start') return app.status !== 'online';
                if (action === 'stop' || action === 'restart') return app.status === 'online';
                return true;
            });
            
            if (availableApps.length === 0) {
                showError(`Действие "${action}" недоступно для выбранных приложений`);
                return;
            }
            
            const availableIds = availableApps.map(app => app.id);
            
            // Подтверждение действия
            const actionNames = {
                'start': 'запустить',
                'stop': 'остановить',
                'restart': 'перезапустить'
            };
            
            const actionName = actionNames[action] || action;
            const appItems = availableApps.map(app => app.name);
            
            ModalUtils.showConfirmModal(
                `${actionName.charAt(0).toUpperCase() + actionName.slice(1)} приложения`,
                `Вы уверены, что хотите <span class="action-name">${actionName}</span> выбранные приложения?`,
                appItems,
                async () => {
                    const result = await ApiService.executeAction(availableIds, action);
                    
                    if (result.success) {
                        const successCount = result.results?.filter(r => r.success).length || 0;
                        const errorCount = result.results?.filter(r => !r.success).length || 0;
                        
                        if (errorCount === 0) {
                            showNotification(`Действие "${actionName}" успешно выполнено`);
                        } else if (successCount > 0) {
                            showNotification(`Действие выполнено для ${successCount} из ${availableIds.length} приложений`);
                        } else {
                            showError(`Не удалось выполнить действие "${actionName}"`);
                        }
                    } else {
                        showError(result.error || `Не удалось выполнить действие "${actionName}"`);
                    }
                    
                    await this.loadApplications();
                },
                `Подтвердить (${availableIds.length})`
            );
        },

        initPagination() {
            // Обработчик кнопок пагинации
            document.addEventListener('click', (e) => {
                if (e.target.classList.contains('page-btn')) {
                    const page = parseInt(e.target.dataset.page);
                    if (!isNaN(page)) {
                        StateManager.state.currentPage = page;
                        this.filterAndDisplayApplications();
                    }
                }
            });
            
            // Обработчик изменения размера страницы
            const pageSizeSelect = document.getElementById('page-size');
            if (pageSizeSelect) {
                pageSizeSelect.addEventListener('change', (e) => {
                    StateManager.state.pageSize = parseInt(e.target.value);
                    StateManager.state.currentPage = 1;
                    this.filterAndDisplayApplications();
                });
            }
        },

        initTableActions() {
            // Делегирование событий для действий в таблице
            document.addEventListener('click', (e) => {
                // Обработчики действий для приложений
                if (e.target.classList.contains('app-info-btn')) {
                    e.preventDefault();
                    const appId = e.target.dataset.appId;
                    this.showAppInfo(appId);
                }
                
                if (e.target.classList.contains('app-update-btn')) {
                    e.preventDefault();
                    const appId = e.target.dataset.appId;
                    ModalManager.showUpdateModal([appId]);
                }
                
                // Обработчики действий для групп
                if (e.target.classList.contains('group-update-btn')) {
                    e.preventDefault();
                    const groupName = e.target.dataset.group;
                    this.handleGroupUpdate(groupName);
                }
                
                // Другие действия
                ['start', 'stop', 'restart'].forEach(action => {
                    if (e.target.classList.contains(`app-${action}-btn`)) {
                        e.preventDefault();
                        if (!e.target.classList.contains('disabled')) {
                            const appId = e.target.dataset.appId;
                            this.handleBatchAction([appId], action);
                        }
                    }
                    
                    if (e.target.classList.contains(`group-${action}-btn`)) {
                        e.preventDefault();
                        if (!e.target.classList.contains('disabled')) {
                            const groupName = e.target.dataset.group;
                            this.handleGroupAction(groupName, action);
                        }
                    }
                });
            });
        },

        handleGroupUpdate(groupName) {
            const appIds = [];
            document.querySelectorAll(`.child-wrapper[data-group="${groupName}"] .app-checkbox`).forEach(checkbox => {
                appIds.push(checkbox.dataset.appId);
            });
            
            if (appIds.length > 0) {
                ModalManager.showUpdateModal(appIds);
            }
        },

        handleGroupAction(groupName, action) {
            const appIds = [];
            document.querySelectorAll(`.child-wrapper[data-group="${groupName}"] .app-checkbox`).forEach(checkbox => {
                appIds.push(checkbox.dataset.appId);
            });
            
            if (appIds.length > 0) {
                this.handleBatchAction(appIds, action);
            }
        },

        async showAppInfo(appId) {
            const app = await ApiService.getApplicationInfo(appId);
            if (!app) {
                showError('Не удалось получить информацию о приложении');
                return;
            }
            
            const sections = [
                {
                    title: 'Основная информация',
                    type: 'table',
                    rows: [
                        { label: 'Имя:', value: app.name },
                        { label: 'Тип:', value: app.app_type || 'Не указан' },
                        { label: 'Статус:', value: `<span class="status-badge ${app.status === 'online' ? 'status-completed' : 'status-failed'}">${app.status || 'Неизвестно'}</span>` },
                        { label: 'Версия:', value: app.version || 'Не указана' },
                        { label: 'Сервер:', value: app.server_name || 'Не указан' },
                        { label: 'IP:', value: app.ip || 'Не указан' },
                        { label: 'Порт:', value: app.port || 'Не указан' }
                    ]
                },
                {
                    title: 'Пути и расположение',
                    type: 'table',
                    rows: [
                        { label: 'Путь приложения:', value: app.path || 'Не указан' },
                        { label: 'Путь к логам:', value: app.log_path || 'Не указан' },
                        { label: 'Путь к дистрибутиву:', value: app.distr_path || 'Не указан' }
                    ]
                }
            ];
            
            if (app.events && app.events.length > 0) {
                let eventsHtml = '<table class="events-table"><thead><tr><th>Дата</th><th>Тип</th><th>Статус</th></tr></thead><tbody>';
                app.events.forEach(event => {
                    const eventDate = new Date(event.timestamp);
                    eventsHtml += `
                        <tr class="event-row ${event.status}">
                            <td>${eventDate.toLocaleString()}</td>
                            <td>${event.event_type}</td>
                            <td>${event.status}</td>
                        </tr>
                    `;
                });
                eventsHtml += '</tbody></table>';
                
                sections.push({
                    title: 'Последние события',
                    type: 'html',
                    content: eventsHtml
                });
            }
            
            ModalUtils.showInfoModal(`Информация о приложении: ${app.name}`, sections);
        },

        async loadApplications() {
            // Не очищаем выбранные элементы при обычной перезагрузке
            // StateManager.clearSelection();
            
            const tbody = document.getElementById('applications-table-body');
            if (tbody) {
                tbody.innerHTML = '<tr><td colspan="6" class="table-loading">Загрузка приложений...</td></tr>';
            }
            
            const applications = await ApiService.loadApplications(StateManager.state.selectedServerId);
            StateManager.state.allApplications = applications;
            
            this.filterAndDisplayApplications();
        },

        filterAndDisplayApplications() {
            let filtered = [...StateManager.state.allApplications];
            
            // Фильтрация по поиску
            if (StateManager.state.searchQuery) {
                filtered = filtered.filter(app => 
                    app.name.toLowerCase().includes(StateManager.state.searchQuery) ||
                    app.status?.toLowerCase().includes(StateManager.state.searchQuery) ||
                    app.server_name?.toLowerCase().includes(StateManager.state.searchQuery)
                );
            }
            
            // Сортировка
            filtered.sort((a, b) => {
                let valueA, valueB;
                const field = StateManager.state.sortColumn;
                
                if (field === 'name') {
                    valueA = a.name?.toLowerCase() || '';
                    valueB = b.name?.toLowerCase() || '';
                } else if (field === 'status') {
                    valueA = a.status?.toLowerCase() || '';
                    valueB = b.status?.toLowerCase() || '';
                } else if (field === 'version') {
                    valueA = a.version?.toLowerCase() || '';
                    valueB = b.version?.toLowerCase() || '';
                } else if (field === 'server') {
                    valueA = a.server_name?.toLowerCase() || '';
                    valueB = b.server_name?.toLowerCase() || '';
                }
                
                const direction = StateManager.state.sortDirection === 'asc' ? 1 : -1;
                if (valueA < valueB) return -direction;
                if (valueA > valueB) return direction;
                return 0;
            });
            
            UIRenderer.renderApplications(filtered);
        }
    };

    // ========================================
    // ИНИЦИАЛИЗАЦИЯ ПРИЛОЖЕНИЯ
    // ========================================
    document.addEventListener('DOMContentLoaded', () => {
        // Инициализация UI элементов
        UIRenderer.init();
        
        // Инициализация обработчиков событий
        EventHandlers.init();
        
        // Загрузка начальных данных
        EventHandlers.loadApplications();
        
        // Добавляем стили для анимаций
        if (!document.getElementById('applications-animations')) {
            const style = document.createElement('style');
            style.id = 'applications-animations';
            style.textContent = `
                .rotating {
                    animation: rotate 1s linear infinite;
                }
                @keyframes rotate {
                    from { transform: rotate(0deg); }
                    to { transform: rotate(360deg); }
                }
                .animated-fade-in {
                    animation: fadeIn 0.3s ease-in;
                }
                @keyframes fadeIn {
                    from { opacity: 0; transform: translateY(10px); }
                    to { opacity: 1; transform: translateY(0); }
                }
                .animated-slide-down {
                    animation: slideDown 0.3s ease-out;
                }
                @keyframes slideDown {
                    from { 
                        opacity: 0; 
                        max-height: 0;
                        transform: translateY(-10px);
                    }
                    to { 
                        opacity: 1; 
                        max-height: 200px;
                        transform: translateY(0);
                    }
                }
                .form-content-animated > .form-group {
                    opacity: 0;
                    animation: fadeIn 0.4s ease-out forwards;
                }
                .form-content-animated > .form-group:nth-child(1) { animation-delay: 0.1s; }
                .form-content-animated > .form-group:nth-child(2) { animation-delay: 0.2s; }
                .form-content-animated > .form-group:nth-child(3) { animation-delay: 0.3s; }
                .form-content-animated > .form-group:nth-child(4) { animation-delay: 0.4s; }
                
                /* Стили для группы */
                .group-toggle {
                    transition: transform 0.3s ease;
                }
                
                /* Стили для кнопки удаления вкладки */
                .modal-tab {
                    position: relative;
                    padding-right: 25px;
                    display: flex;
                    align-items: center;
                    justify-content: space-between;
                }
                
                .tab-content {
                    flex: 1;
                }
                
                .tab-remove-btn {
                    position: absolute;
                    right: 5px;
                    top: 50%;
                    transform: translateY(-50%);
                    background: none;
                    border: none;
                    color: #999;
                    font-size: 18px;
                    line-height: 1;
                    cursor: pointer;
                    width: 20px;
                    height: 20px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    border-radius: 50%;
                    transition: all 0.2s;
                    opacity: 0.6;
                }
                
                .tab-remove-btn:hover {
                    opacity: 1;
                    background-color: rgba(231, 76, 60, 0.1);
                    color: #e74c3c;
                }
                
                .modal-tab:hover .tab-remove-btn {
                    opacity: 1;
                }
                
                .no-groups-message {
                    text-align: center;
                    padding: 40px;
                    color: #999;
                    font-size: 16px;
                }
            `;
            document.head.appendChild(style);
        }
    });

    // Экспорт функций для отладки
    window.ApplicationsDebug = {
        getState: () => StateManager.state,
        getCache: () => StateManager.artifactsCache,
        clearCache: () => StateManager.clearArtifactsCache(),
        debugArtifactsCache: () => {
            console.log('=== Artifacts Cache Debug ===');
            Object.keys(StateManager.artifactsCache).forEach(key => {
                const cache = StateManager.artifactsCache[key];
                const age = Math.round((Date.now() - cache.timestamp) / 1000);
                console.log(`${key}: ${cache.data.length} versions, age: ${age}s`);
            });
            console.log('===========================');
        }
    };

})();
